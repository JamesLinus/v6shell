.\"
.\" Modified by Jeffrey Allen Neitzel, 2003, 2004.
.\"
.\"	Derived from: Sixth Edition (V6) Unix /usr/man/man1/sh.1
.\"
.\" Copyright(C) Caldera International Inc. 2001-2002. All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\"   Redistributions of source code and documentation must retain the
.\"    above copyright notice, this list of conditions and the following
.\"    disclaimer.
.\"   Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"   All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"      This product includes software developed or owned by Caldera
.\"      International, Inc.
.\"   Neither the name of Caldera International, Inc. nor the names of
.\"    other contributors may be used to endorse or promote products
.\"    derived from this software without specific prior written permission.
.\"
.\" USE OF THE SOFTWARE PROVIDED FOR UNDER THIS LICENSE BY CALDERA
.\" INTERNATIONAL, INC. AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL CALDERA INTERNATIONAL, INC. BE
.\" LIABLE FOR ANY DIRECT, INDIRECT INCIDENTAL, SPECIAL, EXEMPLARY, OR
.\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
.\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
.\" BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
.\" WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
.\" OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
.\" EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.TH OSH 1 "February 12, 2004" "Ancient Unix Ports" "User Commands"
.SH NAME
osh \- old shell (command interpreter)
.SH SYNOPSIS
osh [
.B \-c
command ] [
.B \-t
] [ file [ arg1 ... [ arg9 ] ] ]
.SH DESCRIPTION
.I Osh
is a reimplementation of the standard command interpreter
from Sixth Edition
.SM UNIX
which was also distributed as
.I osh
with Seventh Edition
.SM UNIX.
It may be used interactively to read and execute command lines
typed by users.
It may also be used non-interactively to interpret and execute
command files.
The command language is a sparse subset of that found in modern shells
and is mostly common to both
.IR sh (1)
and
.IR csh (1).
.PP
The options are as follows:
.TP
.BI \-c \ command
Execute 
.I command
and exit.
.TP
.B \-t
Read a single line from standard input, execute it as a command, and exit.
.SS Commands
Each command is a sequence of non-blank command arguments
separated by blanks (spaces or tabs).
The first argument specifies the name of a command to be executed.
Except for certain types of special arguments discussed below,
the arguments other than the command name are passed
without interpretation to the invoked command.
.PP
The command name is used to locate the command
by searching the sequence of directories in the environment variable
.SM PATH.
If the command cannot be found, or cannot be executed,
a diagnostic is printed.
.SS Command lines
One or more commands separated by `|' or `^' constitute a chain of
.IR filters .
The standard output of each command but the last
is taken as the standard input of the next command.
Each command is run as a separate process, connected
by pipes (see
.IR pipe (2))
to its neighbors.
A command line contained in parentheses `( )' is executed in a
subshell and may appear in place of a simple command as a filter.
.PP
A
.I "command line"
consists of one or
more pipelines separated, and perhaps terminated by `;' or `&'.
The semicolon designates sequential execution.
The ampersand designates asynchronous execution which causes
the preceding pipeline
to be executed without waiting for it to finish.
The process ID of such a pipeline is reported, so that
it may be used if necessary for a subsequent
.IR kill .
.SS Termination reporting
If a command (not followed by `&') terminates abnormally,
a message is printed.
(All terminations other than exit and interrupt
are considered abnormal.)
Termination reports for commands followed by `&'
are given upon receipt of the first command
subsequent to its termination,
or when a
.I wait
is executed.
The following is a list of the abnormal termination messages:
.PP
.nf
	Hangup
	Quit
	Illegal instruction
	Trace/BPT trap
	IOT trap
	EMT trap
	Floating exception
	Killed
	Bus error
	Memory fault
	Bad system call
	Broken pipe
.fi
.PP
If a core image is produced,
`\-- Core dumped' is appended to the appropriate message.
.SS I/O redirection
There are three character sequences that cause the immediately
following string to be interpreted as a special argument to the
shell itself.
Such an argument may appear anywhere among
the arguments of a simple command, or before or after
a parenthesized command list, and is associated with that
command or command list.
.PP
An argument of the form `<arg' causes the file `arg'
to be used as the standard input (file descriptor 0)
for the associated command.
.PP
An argument of the form `>arg' causes the file `arg'
to be used as the standard output (file descriptor 1)
for the associated command.
`Arg' is created if it did not exist, and in any case
is truncated at the outset.
.PP
An argument of the form `>>arg' causes the file `arg'
to be used as the standard output for the associated command.
If `arg' did not exist, it is created; if it did exist,
the command output is appended to the file.
.PP
For example, either of the command lines
.PP
	date >/tmp/list; ls -l >>/tmp/list
.br
	( date; ls -l ) >/tmp/list
.PP
creates, on file `/tmp/list', the current date and time,
followed immediately by a long listing of the current directory.
.PP
Either of the constructs `>arg' or `>>arg'
associated with any but the last command of a pipeline
is ineffectual, as is `<arg' in any but the first.
.PP
In commands called by the shell,
file descriptor 2 refers to the standard error.
Thus, commands may write diagnostics to a location
where they have a chance to be seen.
.SS File name generation
If any argument contains unquoted `*', `?', or `[' characters,
it is treated specially as follows.
The current directory is searched for files which
.I match
the given argument.
If no file name matches the argument,
it is left unchanged.
The directory entries \fB.\fR and \fB..\fR, and the
.B /
character,
are normally excluded from matches and must be matched explicitly.
.PP
The character `*' in an argument matches any string of characters
in a file name (including the null string).
.PP
The character `?' matches any single character in a file name.
.PP
Square brackets `[...]' specify a class of characters which
matches any single file-name character in the class.
Within the brackets,
each ordinary character is taken
to be a member of the class.
A pair of characters separated by `\-' places
in the class
each character lexically greater than or equal to
the first and less than or equal to the second
member of the pair.
.PP
Other characters match only the same character in
the file name.
.PP
For example, `*' matches all file names;
`?' matches all one-character file names; `[ab]*.s' matches
all file names beginning with `a' or `b' and ending with `.s';
`?[zi\-m]' matches all two-character file names ending
with `z' or the letters `i' through `m'.
.PP
If the argument with `*', `?', or `[' also contains a `/', a slightly
different procedure is used:  instead of the current directory,
the directory used is the one obtained by taking the argument up
to the last `/' before a `*', `?', or `['.
The matching process matches the remainder of the argument
after this `/' against the files in the derived directory.
For example:  `/usr/dmr/a*.s' matches all files
in directory `/usr/dmr' which begin
with `a' and end with `.s'.
.PP
In any event, a list of names is obtained which match
the argument.
This list is sorted into alphabetical order,
and the resulting sequence of arguments replaces the
single argument containing the `*', `?', or `['.
The same process is carried out for each argument
(the resulting lists are
.I not
merged)
and finally the command is called with the resulting list of
arguments.
.SS Quoting
The character `\\' causes the immediately following character
to lose any special meaning it may have to the shell; in this
way `<', `>', and other characters meaningful to the
shell may be passed as part of arguments.
A special case of this feature allows the continuation of commands
onto more than one line:  a new-line preceded by `\\' is translated
into a blank.
.PP
Sequences of characters enclosed in double (") or single (')
quotes are also taken literally.
For example:
.PP
	sed "/^$/d" My_File ^ more
.PP
causes
.I sed
to delete blank lines from `My_File' and pipe the output to
.I more
for viewing.
Quotes prevent the shell from trying to interpret the `^' as a pipe
and the `$' as the beginning of a parameter.
.SS Parameter substitution
When the shell is used non-interactively to execute a command file,
it has additional string processing capabilities.
Recall that the shell can be invoked as follows.
.PP
	osh [ file [ arg1 ... [ arg9 ] ] ]
.PP
In this case,
.I file
is the name of a file which is read and interpreted.
If not given, this instance of the shell is interactive
and continues to read from standard input.
.PP
In command lines in the file (not in command input),
unquoted character sequences of the form `$n', where
.I n
is a digit,
are replaced by the \fIn\fRth argument to the invocation
of the shell (argn).
`$0' is replaced by
.IR file .
.SS End of file
An end-of-file in the shell's input causes it to exit.
If interactive, this means the shell terminates when the
user types an EOF (often represented by `^D') at the
beginning of a line.
.SS Special commands
The following commands are normally treated specially by the shell
but only when not quoted.
Attempts to pipe or redirect these commands have no effect.
.TP
.B "chdir"
[
.I dir
]
.br
changes the shell's working directory to
.IR dir .
In the absence of the
.I dir
argument, the user's home directory is used as the default argument.
If
.I dir
is `-', the previous working directory is used instead.
These are enhancements to chdir which were not available in the
original Sixth Edition
.SM UNIX
shell.
.TP
.B "exit"
terminates command file.
.TP
.B "login"
.IR login (1)
is executed in interactive shells without creating a new process.
.TP
.B "shift"
shifts all positional parameters to the left by 1 with the exception
of `$0' which remains constant.
.TP
.B "wait"
waits for all asynchronous processes.
.TP
.B ":"
is simply ignored and always returns zero.
.SS Command file errors; interrupts
Any shell-detected error, or an interrupt signal,
during the execution of a command file
causes the shell to cease execution of that file.
.PP
Processes that are created with `&' ignore interrupts.
Also if such a process has not redirected its
input with a `<',
its input is automatically redirected from the
zero length file /dev/null.
.SH ENVIRONMENT
.TP
.B HOME
Is the default argument (home directory) for the
.B chdir
command.
.TP
.B PATH
Is used as the search path for external commands.
The original Sixth Edition
.SM UNIX
shell always used `.:/bin:/usr/bin', not
.SM PATH.
.SH FILES
.TP
.B /dev/null
source of input for asynchronous commands
.SH "SEE ALSO"
`The UNIX Time-Sharing System',
CACM, July, 1974,
which gives the theory of operation of the shell.
.br
csh(1),
env(1),
goto(1),
if(1),
login(1),
sh(1)
.SH BUGS
There is no way to redirect the diagnostic output.
